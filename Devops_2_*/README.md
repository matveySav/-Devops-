# 2 Лаба со звездочкой по DevOps

В качестве контейнеров будем использовать структуру из гайда для начинающих по работе с docker compose с оф. сайта [(ссылка)](https://docs.docker.com/compose/gettingstarted/). Получившиеся файлы представлены в данном каталоге. Если кратко, то подняв эти контейнеры, у нас на `localhost:8000` запуститься flask приложение, которое будет выводить, сколько раз мы его посетили. В качестве БД используется контейнер с redis

## Плохие практики
```
services:
  web:
    build: .
    ports:
      - "8000:5000"
  redis:
    image: "redis:alpine"
```
1. В данном варианте compose файла на моменте `8000:5000` мы маппим порт 8000 локальной машине, к 5000 порту контейнера, это не очень оптимально, поскольку наш контейнер с flask приложение будет слушать 8000 порт на всех сетевых интерфейсах, поэтому к нему можно получить доступ не только с нашего пк. 
2. Мы не указываем порядок запуска контейнеров, и поскольку наше веб-приложение обращается к redis, в другом контейнере, его может крашнуть, так как оно не сможет вовремя достучаться до БД (в скрипте предусмотрено некоторое окно для реконнекта, но все же).
3. В данном случае, по аналогии с докерфайлами на моменте `image: "redis:alpine"` мы не указываем конкретную версию образа, что может привести к неприятным последствиям в будущем.

## Тестируем

Поднимаем все наши контейнеры с помощью `docker compose up`

![image](https://github.com/user-attachments/assets/50b72f91-a937-4281-bd35-d9cecaa62322)

Заходим на `localhost:8000` в браузере, теперь у нас страница отображает сколько раз её рефрешнули

![image](https://github.com/user-attachments/assets/97ddc4af-b3d4-459b-95b3-db6f74b75377)

Видим, что все работает как надо.

## Исправление плохих практик
```
services:
  web:
    build: .
    ports:
      - "127.0.0.1:8000:5000"
    depends_on:
      redis:
        condition: service_started
  redis:
    image: "redis:7.4-alpine"
```
1. Здесь в строке `"127.0.0.1:8000:5000"` мы явно указываем, что контейнер должен слушать 8000 порт на хосте только на loopback интерфейсе, то есть до него нельзя достучаться из внешней сети, только с нашей машины.
2. Здесь с помощью аттрибута `depends_on` мы указываем , что наш контейнер с веб-приложением запуститься только после запуска контейнера с БД.
3. Ну, и конечно же, уточнив точную версию образа, мы избавляем себя от рядя потенциальных, проблем в будущем, связанных с совместимостью нашего веб-приложения с другуми версиями образа redis:alpine.

## Тестируем

Меняем содержимое `compose.yaml`, вводим `docker compose up`, все опять работает, в начале контейнер с redis запускается первым, и завершается последним

![image](https://github.com/user-attachments/assets/7f49268c-0876-412c-9077-e2439edc64b1)

И конечно же сама страница все таа
![image](https://github.com/user-attachments/assets/c591d8fa-2ead-4931-b36e-c3d6d0bbbc65)


## Поднимаем 2 контейнера так, чтобы они не видели друг друга по сети
Сначала я думал поднять просто добавить правило в firewall одного из контейнеров, но потом я осознал, что образ-то alpine, а не ubuntu, поэтому там вроде как нет привычного ufw или iptables, поэтому чтобы не мучаться с их настройкой и установкой(это ведь придется менять докерфайл), я решил просто поднять 2 сети, по контейнеру в каждой, таким образом получил такой `compose.yaml`
```
services:
  web:
    build: .
    ports:
      - "127.0.0.1:8000:5000"
    depends_on:
      redis:
        condition: service_started
    networks:
      - app_network
  redis:
    image: "redis:7.4-alpine"
    networks:
      - redis_network

networks:
  app_network:
    driver: bridge
  redis_network:
    driver: bridge
```
Теперь когда мы `docker compose build` и `docker compose up`, мы видим, что наши контейнеры работают, но поскольку они находятся в разных сетях, то они не пингуют друг друга, а также функционал веб приложения перестал работать, поскольку они с БДшкой работали в паре, но не суть, для примера это не важно. <br/>
![image](https://github.com/user-attachments/assets/df0b9200-4fc5-4dcc-860e-b4815db0633b)
![image](https://github.com/user-attachments/assets/3b8c5fee-ada4-422d-8e6f-3b590948cfc4)
![image](https://github.com/user-attachments/assets/de2d1279-6d72-471e-b400-d098a373828a)
![image](https://github.com/user-attachments/assets/e1ca92f4-5a8e-46ff-9fde-6a564016ac63)

Здесь видно, что контейнер с веб приложением не может достучаться до контейнера с redis'ом, так как они не имеют общей сети.

# Итог
Были определены 3 плохих практики по работе с docker compsoe файлами, которые были исправлены, также были подняты два контейнера таким образом, что они находятся в разных сетях, поэтому не видят друг друга. Так были выполнены все пункты лабораторной работы 2*.
